// This package implements arbitrary sized public key encryption using rsa. It supports PEM/PKIX encoded keys as, e.g.
// generated by openssl (see documentation). The main functions are GenerateKey, Encrypt and Decrypt.
//
// Internally, a 32 byte key is generated and the input stream's content is encrypted using AES. The (symmetric) key is
// encrypted using the public key. The resulting encrypted key and the symmetrically encrypted data are then
// persisted in the output stream.
//
// Note that we currently do not have sophisticated error handling in place, i.e. we usually simply panic() if a
// function returns a non-nil error value.
package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/gob"
	"io"
	"log"
)

const keyLength = 32

// Default source for randomess. Can be fixed for unit tests using randReader(io.Readder).
var randReader = rand.Reader

// Message in -> encrypted data out
type encryptedData struct {
	Data         []byte // Protected by AES.
	EncryptedKey []byte // Protected by private key.
	NonceSize    int    // Necessary for AES randomness.
}

// GenerateKey creates a new rsa public key pair with the given bit size.
func GenerateKey(bitSize int) (rsa.PublicKey, rsa.PrivateKey) {
	key, _ := rsa.GenerateKey(randReader, bitSize)
	pub := key.PublicKey
	return pub, *key
}

// Encrypt a byte slice using the given public key (see package description for actual process) and returns the
// encrypted datawhich can be decrypted using Decrypt().
func Encrypt(data []byte, key *rsa.PublicKey) []byte {
	aesKey, nonceSize, data := encryptSymmetric(data)
	encryptedKey := encryptAsymmetric(aesKey, key)

	ed := encryptedData{data, encryptedKey, nonceSize}
	var buffer bytes.Buffer
	enc := gob.NewEncoder(&buffer)
	err := enc.Encode(ed)
	if err != nil {
		panic(err)
	}
	return buffer.Bytes()
}

// encryptSymmetric encryptes the message using a randomly generated symmetric key.
func encryptSymmetric(message []byte) (symmetricKey []byte, nonceSize int, data []byte) {
	symmetricKey = newRandomKey(keyLength)

	gcm := createGCMEncryptionWithAES(symmetricKey)

	// Create random nonce and prepend it to the message.
	nonceSize = gcm.NonceSize()
	nonce := make([]byte, nonceSize)
	io.ReadFull(randReader, nonce)

	// encryptSymmetric
	data = gcm.Seal(nonce, nonce, message, nil)
	return
}

// newRandomKey returns a new key with the given length (in bytes), i.e. multiply by 8 for bits.
func newRandomKey(keyLength int) []byte {
	key := make([]byte, keyLength)
	_, err := randReader.Read(key)
	if err != nil {
		panic(err)
	}
	return key
}

// encryptAsymmetric encrypts a message using a public key.
func encryptAsymmetric(message []byte, key *rsa.PublicKey) []byte {
	ciphertext, err := rsa.EncryptOAEP(sha256.New(), randReader, key, message, nil)
	if err != nil {
		panic(err)
	}
	return ciphertext
}

// Decrypt a byte array using the given private key. Returns the decrypted byte stream.
func Decrypt(data []byte, key *rsa.PrivateKey) []byte {
	dec := gob.NewDecoder(bytes.NewReader(data))
	var ed encryptedData
	err := dec.Decode(&ed)
	if err != nil {
		panic(err)
	}

	symmetricKey := decryptAsymmetric(ed.EncryptedKey, key)
	decryptedPlaintext := decryptSymmetric(ed.Data, ed.NonceSize, symmetricKey)
	return decryptedPlaintext
}

// decryptAsymmetric decrypts a message using a private key.
func decryptAsymmetric(message []byte, key *rsa.PrivateKey) []byte {
	plaintext, err := rsa.DecryptOAEP(sha256.New(), nil, key, message, nil)
	if err != nil {
		panic(err)
	}
	return plaintext
}

// decryptSymmetric decrypts a message.
func decryptSymmetric(data []byte, nonceSize int, key []byte) []byte {
	nonce, message := data[:nonceSize], data[nonceSize:]
	gcm := createGCMEncryptionWithAES(key)
	plain, err := gcm.Open(nil, nonce, message, nil)
	if err != nil {
		panic(err)
	}
	return plain
}

// createGCMEncryptionWithAES creates a GCM cipher which can be used to encrypt a stream of blocks using AES.
func createGCMEncryptionWithAES(key []byte) cipher.AEAD {
	// Create AES instance using random key.
	algorithm, err := aes.NewCipher(key)
	if err != nil {
		panic(err)
	}
	// Create corresponding block encryption.
	gcm, err := cipher.NewGCM(algorithm)
	if err != nil {
		panic(err)
	}
	return gcm
}

// fixRandomReader sets a new random reader which is used for retrieving random values. This is useful for unit tests.
func fixRandomReader(reader io.Reader) {
	log.Println("Using non-default random source. Running in a test?")
	randReader = reader
}
